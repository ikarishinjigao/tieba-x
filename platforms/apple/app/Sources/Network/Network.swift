// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(TiebaxFFI)
import TiebaxFFI
#endif

extension RustBuffer {
  // Allocate a new buffer, copying the contents of a `UInt8` array.
  fileprivate init(bytes: [UInt8]) {
    let rbuf = bytes.withUnsafeBufferPointer { ptr in
      RustBuffer.from(ptr)
    }
    self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
  }

  fileprivate static func empty() -> RustBuffer {
    RustBuffer(capacity: 0, len: 0, data: nil)
  }

  fileprivate static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
    try! rustCall { ffi_network_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
  }

  // Frees the buffer in place.
  // The buffer must not be used after this is called.
  fileprivate func deallocate() {
    try! rustCall { ffi_network_rustbuffer_free(self, $0) }
  }
}

extension ForeignBytes {
  fileprivate init(bufferPointer: UnsafeBufferPointer<UInt8>) {
    self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
  }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

extension Data {
  fileprivate init(rustBuffer: RustBuffer) {
    self.init(
      bytesNoCopy: rustBuffer.data!,
      count: Int(rustBuffer.len),
      deallocator: .none
    )
  }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
  (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
  let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
  guard reader.data.count >= range.upperBound else {
    throw UniffiInternalError.bufferOverflow
  }
  if T.self == UInt8.self {
    let value = reader.data[reader.offset]
    reader.offset += 1
    return value as! T
  }
  var value: T = 0
  let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
  reader.offset = range.upperBound
  return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
  let range = reader.offset ..< (reader.offset + count)
  guard reader.data.count >= range.upperBound else {
    throw UniffiInternalError.bufferOverflow
  }
  var value = [UInt8](repeating: 0, count: count)
  value.withUnsafeMutableBufferPointer { buffer in
    reader.data.copyBytes(to: buffer, from: range)
  }
  reader.offset = range.upperBound
  return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
  try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
  try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
  reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
  []
}

private func writeBytes(_ writer: inout [UInt8], _ byteArr: some Sequence<UInt8>) {
  writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt(_ writer: inout [UInt8], _ value: some FixedWidthInteger) {
  var value = value.bigEndian
  withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
  writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
  writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
  associatedtype FfiType
  associatedtype SwiftType

  static func lift(_ value: FfiType) throws -> SwiftType
  static func lower(_ value: SwiftType) -> FfiType
  static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
  static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
  public static func lift(_ value: FfiType) throws -> SwiftType {
    value
  }

  public static func lower(_ value: SwiftType) -> FfiType {
    value
  }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
  public static func lift(_ buf: RustBuffer) throws -> SwiftType {
    var reader = createReader(data: Data(rustBuffer: buf))
    let value = try read(from: &reader)
    if hasRemaining(reader) {
      throw UniffiInternalError.incompleteData
    }
    buf.deallocate()
    return value
  }

  public static func lower(_ value: SwiftType) -> RustBuffer {
    var writer = createWriter()
    write(value, into: &writer)
    return RustBuffer(bytes: writer)
  }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
  case bufferOverflow
  case incompleteData
  case unexpectedOptionalTag
  case unexpectedEnumCase
  case unexpectedNullPointer
  case unexpectedRustCallStatusCode
  case unexpectedRustCallError
  case unexpectedStaleHandle
  case rustPanic(_ message: String)

  public var errorDescription: String? {
    switch self {
    case .bufferOverflow: "Reading the requested value would read past the end of the buffer"
    case .incompleteData: "The buffer still has data after lifting its containing value"
    case .unexpectedOptionalTag: "Unexpected optional tag; should be 0 or 1"
    case .unexpectedEnumCase: "Raw enum value doesn't match any cases"
    case .unexpectedNullPointer: "Raw pointer value was null"
    case .unexpectedRustCallStatusCode: "Unexpected RustCallStatus code"
    case .unexpectedRustCallError: "CALL_ERROR but no errorClass specified"
    case .unexpectedStaleHandle: "The object in the handle map has been dropped already"
    case let .rustPanic(message): message
    }
  }
}

extension NSLock {
  fileprivate func withLock<T>(f: () throws -> T) rethrows -> T {
    lock()
    defer { self.unlock() }
    return try f()
  }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

extension RustCallStatus {
  fileprivate init() {
    self.init(
      code: CALL_SUCCESS,
      errorBuf: RustBuffer(
        capacity: 0,
        len: 0,
        data: nil
      )
    )
  }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
  let neverThrow: ((RustBuffer) throws -> Never)? = nil
  return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T>(
  _ errorHandler: @escaping (RustBuffer) throws -> some Swift.Error,
  _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
  try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
  _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
  errorHandler: ((RustBuffer) throws -> some Swift.Error)?
) throws -> T {
  uniffiEnsureInitialized()
  var callStatus = RustCallStatus()
  let returnedVal = callback(&callStatus)
  try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
  return returnedVal
}

private func uniffiCheckCallStatus(
  callStatus: RustCallStatus,
  errorHandler: ((RustBuffer) throws -> some Swift.Error)?
) throws {
  switch callStatus.code {
  case CALL_SUCCESS:
    return

  case CALL_ERROR:
    if let errorHandler {
      throw try errorHandler(callStatus.errorBuf)
    } else {
      callStatus.errorBuf.deallocate()
      throw UniffiInternalError.unexpectedRustCallError
    }

  case CALL_UNEXPECTED_ERROR:
    // When the rust code sees a panic, it tries to construct a RustBuffer
    // with the message.  But if that code panics, then it just sends back
    // an empty buffer.
    if callStatus.errorBuf.len > 0 {
      throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
    } else {
      callStatus.errorBuf.deallocate()
      throw UniffiInternalError.rustPanic("Rust panic")
    }

  case CALL_CANCELLED:
    fatalError("Cancellation not supported yet")

  default:
    throw UniffiInternalError.unexpectedRustCallStatusCode
  }
}

private func uniffiTraitInterfaceCall<T>(
  callStatus: UnsafeMutablePointer<RustCallStatus>,
  makeCall: () throws -> T,
  writeReturn: (T) -> Void
) {
  do {
    try writeReturn(makeCall())
  } catch {
    callStatus.pointee.code = CALL_UNEXPECTED_ERROR
    callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
  }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
  callStatus: UnsafeMutablePointer<RustCallStatus>,
  makeCall: () throws -> T,
  writeReturn: (T) -> Void,
  lowerError: (E) -> RustBuffer
) {
  do {
    try writeReturn(makeCall())
  } catch let error as E {
    callStatus.pointee.code = CALL_ERROR
    callStatus.pointee.errorBuf = lowerError(error)
  } catch {
    callStatus.pointee.code = CALL_UNEXPECTED_ERROR
    callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
  }
}

private class UniffiHandleMap<T> {
  private var map: [UInt64: T] = [:]
  private let lock = NSLock()
  private var currentHandle: UInt64 = 1

  func insert(obj: T) -> UInt64 {
    lock.withLock {
      let handle = currentHandle
      currentHandle += 1
      map[handle] = obj
      return handle
    }
  }

  func get(handle: UInt64) throws -> T {
    try lock.withLock {
      guard let obj = map[handle] else {
        throw UniffiInternalError.unexpectedStaleHandle
      }
      return obj
    }
  }

  @discardableResult
  func remove(handle: UInt64) throws -> T {
    try lock.withLock {
      guard let obj = map.removeValue(forKey: handle) else {
        throw UniffiInternalError.unexpectedStaleHandle
      }
      return obj
    }
  }

  var count: Int {
    map.count
  }
}

// Public interface members begin here.

private struct FfiConverterUInt16: FfiConverterPrimitive {
  typealias FfiType = UInt16
  typealias SwiftType = UInt16

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
    try lift(readInt(&buf))
  }

  public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
  typealias FfiType = Int32
  typealias SwiftType = Int32

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
    try lift(readInt(&buf))
  }

  public static func write(_ value: Int32, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
  typealias FfiType = Int64
  typealias SwiftType = Int64

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
    try lift(readInt(&buf))
  }

  public static func write(_ value: Int64, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

private struct FfiConverterBool: FfiConverter {
  typealias FfiType = Int8
  typealias SwiftType = Bool

  public static func lift(_ value: Int8) throws -> Bool {
    value != 0
  }

  public static func lower(_ value: Bool) -> Int8 {
    value ? 1 : 0
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
    try lift(readInt(&buf))
  }

  public static func write(_ value: Bool, into buf: inout [UInt8]) {
    writeInt(&buf, lower(value))
  }
}

private struct FfiConverterString: FfiConverter {
  typealias SwiftType = String
  typealias FfiType = RustBuffer

  public static func lift(_ value: RustBuffer) throws -> String {
    defer {
      value.deallocate()
    }
    if value.data == nil {
      return String()
    }
    let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
    return String(bytes: bytes, encoding: String.Encoding.utf8)!
  }

  public static func lower(_ value: String) -> RustBuffer {
    value.utf8CString.withUnsafeBufferPointer { ptr in
      // The swift string gives us int8_t, we want uint8_t.
      ptr.withMemoryRebound(to: UInt8.self) { ptr in
        // The swift string gives us a trailing null byte, we don't want it.
        let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
        return RustBuffer.from(buf)
      }
    }
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
    let len: Int32 = try readInt(&buf)
    return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
  }

  public static func write(_ value: String, into buf: inout [UInt8]) {
    let len = Int32(value.utf8.count)
    writeInt(&buf, len)
    writeBytes(&buf, value.utf8)
  }
}

public protocol ApiClientProtocol: AnyObject {
  func getThreads(request: GetThreadsRequest) async throws -> GetThreadsResponse
}

open class ApiClient:
  ApiClientProtocol
{
  fileprivate let pointer: UnsafeMutableRawPointer!

  /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
  public struct NoPointer {
    public init() {}
  }

  // TODO: We'd like this to be `private` but for Swifty reasons,
  // we can't implement `FfiConverter` without making this `required` and we can't
  // make it `required` without making it `public`.
  public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
    self.pointer = pointer
  }

  /// This constructor can be used to instantiate a fake object.
  /// - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be
  /// implemented for classes extending [FFIObject].
  ///
  /// - Warning:
  ///     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a
  /// backing [Pointer] the FFI lower functions will crash.
  public init(noPointer _: NoPointer) {
    self.pointer = nil
  }

  public func uniffiClonePointer() -> UnsafeMutableRawPointer {
    try! rustCall { uniffi_network_fn_clone_apiclient(self.pointer, $0) }
  }

  public convenience init() {
    let pointer =
      try! rustCall {
        uniffi_network_fn_constructor_apiclient_new(
          $0
        )
      }
    self.init(unsafeFromRawPointer: pointer)
  }

  deinit {
    guard let pointer else {
      return
    }

    try! rustCall { uniffi_network_fn_free_apiclient(pointer, $0) }
  }

  open func getThreads(request: GetThreadsRequest) async throws -> GetThreadsResponse {
    try await uniffiRustCallAsync(
      rustFutureFunc: {
        uniffi_network_fn_method_apiclient_get_threads(
          self.uniffiClonePointer(),
          FfiConverterTypeGetThreadsRequest.lower(request)
        )
      },
      pollFunc: ffi_network_rust_future_poll_rust_buffer,
      completeFunc: ffi_network_rust_future_complete_rust_buffer,
      freeFunc: ffi_network_rust_future_free_rust_buffer,
      liftFunc: FfiConverterTypeGetThreadsResponse.lift,
      errorHandler: FfiConverterTypeError.lift
    )
  }
}

public struct FfiConverterTypeApiClient: FfiConverter {
  typealias FfiType = UnsafeMutableRawPointer
  typealias SwiftType = ApiClient

  public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ApiClient {
    ApiClient(unsafeFromRawPointer: pointer)
  }

  public static func lower(_ value: ApiClient) -> UnsafeMutableRawPointer {
    value.uniffiClonePointer()
  }

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiClient {
    let v: UInt64 = try readInt(&buf)
    // The Rust code won't compile if a pointer won't fit in a UInt64.
    // We have to go via `UInt` because that's the thing that's the size of a pointer.
    let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
    if ptr == nil {
      throw UniffiInternalError.unexpectedNullPointer
    }
    return try lift(ptr!)
  }

  public static func write(_ value: ApiClient, into buf: inout [UInt8]) {
    // This fiddling is because `Int` is the thing that's the same size as a pointer.
    // The Rust code won't compile if a pointer won't fit in a `UInt64`.
    writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
  }
}

public func FfiConverterTypeApiClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> ApiClient {
  try FfiConverterTypeApiClient.lift(pointer)
}

public func FfiConverterTypeApiClient_lower(_ value: ApiClient) -> UnsafeMutableRawPointer {
  FfiConverterTypeApiClient.lower(value)
}

public struct ApiError {
  public var errorCode: Int32
  public var errorMessage: String
  public var userMessage: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(errorCode: Int32, errorMessage: String, userMessage: String) {
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.userMessage = userMessage
  }
}

extension ApiError: Equatable, Hashable {
  public static func == (lhs: ApiError, rhs: ApiError) -> Bool {
    if lhs.errorCode != rhs.errorCode {
      return false
    }
    if lhs.errorMessage != rhs.errorMessage {
      return false
    }
    if lhs.userMessage != rhs.userMessage {
      return false
    }
    return true
  }

  public func hash(into hasher: inout Hasher) {
    hasher.combine(errorCode)
    hasher.combine(errorMessage)
    hasher.combine(userMessage)
  }
}

public struct FfiConverterTypeApiError: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiError {
    try ApiError(
      errorCode: FfiConverterInt32.read(from: &buf),
      errorMessage: FfiConverterString.read(from: &buf),
      userMessage: FfiConverterString.read(from: &buf)
    )
  }

  public static func write(_ value: ApiError, into buf: inout [UInt8]) {
    FfiConverterInt32.write(value.errorCode, into: &buf)
    FfiConverterString.write(value.errorMessage, into: &buf)
    FfiConverterString.write(value.userMessage, into: &buf)
  }
}

public func FfiConverterTypeApiError_lift(_ buf: RustBuffer) throws -> ApiError {
  try FfiConverterTypeApiError.lift(buf)
}

public func FfiConverterTypeApiError_lower(_ value: ApiError) -> RustBuffer {
  FfiConverterTypeApiError.lower(value)
}

public struct GetThreadsRequest {
  public var forumName: String
  public var pageNumber: Int32
  public var pageSize: Int32
  public var sortType: ThreadSortType
  public var isHighQualityThread: Bool

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(forumName: String, pageNumber: Int32, pageSize: Int32, sortType: ThreadSortType, isHighQualityThread: Bool) {
    self.forumName = forumName
    self.pageNumber = pageNumber
    self.pageSize = pageSize
    self.sortType = sortType
    self.isHighQualityThread = isHighQualityThread
  }
}

extension GetThreadsRequest: Equatable, Hashable {
  public static func == (lhs: GetThreadsRequest, rhs: GetThreadsRequest) -> Bool {
    if lhs.forumName != rhs.forumName {
      return false
    }
    if lhs.pageNumber != rhs.pageNumber {
      return false
    }
    if lhs.pageSize != rhs.pageSize {
      return false
    }
    if lhs.sortType != rhs.sortType {
      return false
    }
    if lhs.isHighQualityThread != rhs.isHighQualityThread {
      return false
    }
    return true
  }

  public func hash(into hasher: inout Hasher) {
    hasher.combine(forumName)
    hasher.combine(pageNumber)
    hasher.combine(pageSize)
    hasher.combine(sortType)
    hasher.combine(isHighQualityThread)
  }
}

public struct FfiConverterTypeGetThreadsRequest: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetThreadsRequest {
    try GetThreadsRequest(
      forumName: FfiConverterString.read(from: &buf),
      pageNumber: FfiConverterInt32.read(from: &buf),
      pageSize: FfiConverterInt32.read(from: &buf),
      sortType: FfiConverterTypeThreadSortType.read(from: &buf),
      isHighQualityThread: FfiConverterBool.read(from: &buf)
    )
  }

  public static func write(_ value: GetThreadsRequest, into buf: inout [UInt8]) {
    FfiConverterString.write(value.forumName, into: &buf)
    FfiConverterInt32.write(value.pageNumber, into: &buf)
    FfiConverterInt32.write(value.pageSize, into: &buf)
    FfiConverterTypeThreadSortType.write(value.sortType, into: &buf)
    FfiConverterBool.write(value.isHighQualityThread, into: &buf)
  }
}

public func FfiConverterTypeGetThreadsRequest_lift(_ buf: RustBuffer) throws -> GetThreadsRequest {
  try FfiConverterTypeGetThreadsRequest.lift(buf)
}

public func FfiConverterTypeGetThreadsRequest_lower(_ value: GetThreadsRequest) -> RustBuffer {
  FfiConverterTypeGetThreadsRequest.lower(value)
}

public struct GetThreadsResponse {
  public var forumId: Int64
  public var forumName: String

  // Default memberwise initializers are never public by default, so we
  // declare one manually.
  public init(forumId: Int64, forumName: String) {
    self.forumId = forumId
    self.forumName = forumName
  }
}

extension GetThreadsResponse: Equatable, Hashable {
  public static func == (lhs: GetThreadsResponse, rhs: GetThreadsResponse) -> Bool {
    if lhs.forumId != rhs.forumId {
      return false
    }
    if lhs.forumName != rhs.forumName {
      return false
    }
    return true
  }

  public func hash(into hasher: inout Hasher) {
    hasher.combine(forumId)
    hasher.combine(forumName)
  }
}

public struct FfiConverterTypeGetThreadsResponse: FfiConverterRustBuffer {
  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetThreadsResponse {
    try GetThreadsResponse(
      forumId: FfiConverterInt64.read(from: &buf),
      forumName: FfiConverterString.read(from: &buf)
    )
  }

  public static func write(_ value: GetThreadsResponse, into buf: inout [UInt8]) {
    FfiConverterInt64.write(value.forumId, into: &buf)
    FfiConverterString.write(value.forumName, into: &buf)
  }
}

public func FfiConverterTypeGetThreadsResponse_lift(_ buf: RustBuffer) throws -> GetThreadsResponse {
  try FfiConverterTypeGetThreadsResponse.lift(buf)
}

public func FfiConverterTypeGetThreadsResponse_lower(_ value: GetThreadsResponse) -> RustBuffer {
  FfiConverterTypeGetThreadsResponse.lower(value)
}

public enum Error {
  case Client(
    errorMessage: String
  )
  case Encode(
    errorMessage: String
  )
  case Decode(
    errorMessage: String
  )
  case UnexpectedStatusCode(
    statusCode: UInt16
  )
  case Api(
    apiError: ApiError
  )
}

public struct FfiConverterTypeError: FfiConverterRustBuffer {
  typealias SwiftType = Error

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Error {
    let variant: Int32 = try readInt(&buf)
    switch variant {
    case 1: return try .Client(
        errorMessage: FfiConverterString.read(from: &buf)
      )
    case 2: return try .Encode(
        errorMessage: FfiConverterString.read(from: &buf)
      )
    case 3: return try .Decode(
        errorMessage: FfiConverterString.read(from: &buf)
      )
    case 4: return try .UnexpectedStatusCode(
        statusCode: FfiConverterUInt16.read(from: &buf)
      )
    case 5: return try .Api(
        apiError: FfiConverterTypeApiError.read(from: &buf)
      )
    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: Error, into buf: inout [UInt8]) {
    switch value {
    case let .Client(errorMessage):
      writeInt(&buf, Int32(1))
      FfiConverterString.write(errorMessage, into: &buf)

    case let .Encode(errorMessage):
      writeInt(&buf, Int32(2))
      FfiConverterString.write(errorMessage, into: &buf)

    case let .Decode(errorMessage):
      writeInt(&buf, Int32(3))
      FfiConverterString.write(errorMessage, into: &buf)

    case let .UnexpectedStatusCode(statusCode):
      writeInt(&buf, Int32(4))
      FfiConverterUInt16.write(statusCode, into: &buf)

    case let .Api(apiError):
      writeInt(&buf, Int32(5))
      FfiConverterTypeApiError.write(apiError, into: &buf)
    }
  }
}

extension Error: Equatable, Hashable {}

extension Error: Foundation.LocalizedError {
  public var errorDescription: String? {
    String(reflecting: self)
  }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ThreadSortType: Int32 {
  case createTime = 1
  case followedOnly = 2
  case popularity = 3
  case replyTime = 5
}

public struct FfiConverterTypeThreadSortType: FfiConverterRustBuffer {
  typealias SwiftType = ThreadSortType

  public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThreadSortType {
    let variant: Int32 = try readInt(&buf)
    switch variant {
    case 1: return .createTime

    case 2: return .followedOnly

    case 3: return .popularity

    case 4: return .replyTime

    default: throw UniffiInternalError.unexpectedEnumCase
    }
  }

  public static func write(_ value: ThreadSortType, into buf: inout [UInt8]) {
    switch value {
    case .createTime:
      writeInt(&buf, Int32(1))

    case .followedOnly:
      writeInt(&buf, Int32(2))

    case .popularity:
      writeInt(&buf, Int32(3))

    case .replyTime:
      writeInt(&buf, Int32(4))
    }
  }
}

public func FfiConverterTypeThreadSortType_lift(_ buf: RustBuffer) throws -> ThreadSortType {
  try FfiConverterTypeThreadSortType.lift(buf)
}

public func FfiConverterTypeThreadSortType_lower(_ value: ThreadSortType) -> RustBuffer {
  FfiConverterTypeThreadSortType.lower(value)
}

extension ThreadSortType: Equatable, Hashable {}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
  rustFutureFunc: () -> UInt64,
  pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
  completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
  freeFunc: (UInt64) -> Void,
  liftFunc: (F) throws -> T,
  errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
  // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
  // RustCallStatus param, so doesn't use makeRustCall()
  uniffiEnsureInitialized()
  let rustFuture = rustFutureFunc()
  defer {
    freeFunc(rustFuture)
  }
  var pollResult: Int8
  repeat {
    pollResult = await withUnsafeContinuation {
      pollFunc(
        rustFuture,
        uniffiFutureContinuationCallback,
        uniffiContinuationHandleMap.insert(obj: $0)
      )
    }
  } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

  return try liftFunc(makeRustCall(
    { completeFunc(rustFuture, $0) },
    errorHandler: errorHandler
  ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
  if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
    continuation.resume(returning: pollResult)
  } else {
    print("uniffiFutureContinuationCallback invalid handle")
  }
}

private enum InitializationResult {
  case ok
  case contractVersionMismatch
  case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
  // Get the bindings contract version from our ComponentInterface
  let bindings_contract_version = 26
  // Get the scaffolding contract version by calling the into the dylib
  let scaffolding_contract_version = ffi_network_uniffi_contract_version()
  if bindings_contract_version != scaffolding_contract_version {
    return InitializationResult.contractVersionMismatch
  }
  if uniffi_network_checksum_method_apiclient_get_threads() != 34801 {
    return InitializationResult.apiChecksumMismatch
  }
  if uniffi_network_checksum_constructor_apiclient_new() != 55646 {
    return InitializationResult.apiChecksumMismatch
  }

  return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
  switch initializationResult {
  case .ok:
    break
  case .contractVersionMismatch:
    fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
  case .apiChecksumMismatch:
    fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
  }
}

// swiftlint:enable all
